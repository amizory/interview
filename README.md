# Interview

* [Linux](#Linux)
* [Web](#Web)
* [PostgreSQL](#PostgreSQL)
* [k8s](#k8s)
* [Ansible](#Ansible)
* [Bash](#Bash)
* [OBS](#OBS)

## Questions

### <a id="Linux">Linux</a>

```txt
1 - Место на диске?

->  df -h (--total)
    du -ms 

    - rm /var/log/postgresql/postgres.log -> удалить архивы
    - truncate -s 0 /var/log/postgresql/postgres.log -> подрезать
    - logrotate -d /var/log/postgresql/postgres.log -s 100M -m 7 
    - linux file system -> резервное место
    - clear journalctl -> vacuum
```

```txt
2 - Автозагрузка приложения

->  - systemctl edit --full name.service
      systemctl daemon-reload
    - etc/rc.local -> !#bin/bash -> /PATH -> exit 0
    - etc/systemd/system/name.service -> [Unit - Service - Install]
      systemctl enable name.service
    - .bashrc -> /PATH
    - update-rc.d name default
    - chkconfig name on  
```

```txt
3 - Память, cpu

->  top, htop, lsmem, lscpu, free
    CPU - LoadAverage - число/количество ядер, среднее значение количества процессов, ожидающих
    выполнения в очереди процессора, за определенный период времени. Этот показатель
    рассчитывается на основе информации о процессах, которые находятся в состоянии ожидания
    (waiting) или готовы к выполнению (runnable). 
    1, 5 и 15 минут
    - Процессы в состоянии ожидания (waiting): Это процессы, которые ожидают завершения
    операции ввода/вывода (I/O) или других ресурсов.
    - Процессы в состоянии готовности к выполнению (runnable): Это процессы, которые готовы к
    выполнению, но не могут быть выполнены из-за нехватки ресурсов (например, процессорного
    времени)
    - Процессы в состоянии сна (sleeping): Это процессы, которые находятся в состоянии сна и
    не могут быть выполнены до тех пор, пока не будет получен сигнал или не истечет определенный
    период времени

    uptime/top
    load average
    (Σ(процессы в состоянии ожидания + процессы в состоянии готовности к выполнению)) / 
    (количество процессоров × время измерения)
```

```txt
4 - Процессы

->  ps -> вывод информации о процессах, включая их идентификаторы (PID),
          имя процесса, владельца процесса, использование ресурсов (память, CPU) и другую
          полезную информацию
        -a или --all: Выводит информацию обо всех процессах, которые запущены на терминале.
        -e или --everything: Показывает информацию обо всех процессах.
        -f или --full-format: Используется для вывода информации в полном формате
```

```txt
6 - lsof

->  - Список открытых файлов lsof -c <имя_процесса>
    - Процессы, открывшие файлы
    - Типы открытых файлов (REG (regular file), DIR (директория), CHR (character special file),
    BLK (block special file), FIFO (named pipe), SOCK (socket))
    - Параметры файлов (права доступа, владелец и группа)
    - Сокеты и сетевые соединения (включая номера портов, протоколы (TCP, UDP, и т.д.) и статус
    соединения)
    - Pipes и сокеты домена Unix (межпроцессное взаимодействие) lsof -i
    - Версии библиотек и исполняемых файлов
    - Информация о PID и названии процесса lsof -p <PID>
```

```txt
7 - Дескрипторы

->  Дескрипторы в Linux — это целые числа, которые используются для идентификации открытых
    файлов, сетевых соединений и других ресурсов в операционной системе. Когда процесс
    открывает файл или создаёт сетевое соединение, ядро Linux возвращает дескриптор, который
    затем используется процессом для доступа к этому ресурсу.

    Файловые дескрипторы (FD) — это тип дескрипторов, которые используются для доступа к файлам.
    Каждый процесс в Linux имеет свой собственный набор файловых дескрипторов, которые начинаются
    с 0 и увеличиваются при открытии новых файлов. Например, дескриптор 0 обычно соответствует
    стандартному входному потоку (STDIN), дескриптор 1 — стандартному выводу (STDOUT), а
    дескриптор 2 — стандартному потоку ошибок (STDERR).

    ps -p 1234 -o fd
    lsof -p 1234
    ls /proc/1234/fd


    - Файловые дескрипторы (FD): используются для доступа к файлам    - 
    - Сокет-дескрипторы (SD): используются для доступа к сетевым соединениям, таких как TCP/IP
    или UDP.
    - Пайп-дескрипторы (PD): используются для доступа к каналам (pipes), которые позволяют
    передавать данные между процессами.
    - Символьные дескрипторы (SD): используются для доступа к символьным устройствам, таким как
    терминалы или принтеры.
    - Блочные дескрипторы (BD): используются для доступа к блочным устройствам, таким как
    жесткие диски или флеш-накопители.
    - Специальные дескрипторы (SPD): используются для доступа к специальным устройствам, таким
    как /dev/null или /dev/zero.
    - Дескрипторы процессов (PD): используются для доступа к процессам, таким как PID или PGID.
    - Дескрипторы потоков (TD): используются для доступа к потокам, таким как потоки
    ввода/вывода или потоки ошибок.
    - Дескрипторы сигналов (SD): используются для доступа к сигналам, таким как SIGINT или
    SIGTERM.

    Кроме того, в Linux есть следующие специальные дескрипторы:
    - STDIN (0): стандартный входной поток.
    - STDOUT (1): стандартный выводной поток.
    - STDERR (2): стандартный поток ошибок.
    - /dev/null (3): специальный файл, который игнорирует все данные, записанные в него.
    - /dev/zero (4): специальный файл, который возвращает нулевые байты при чтении.
    - /dev/random (5): специальный файл, который возвращает случайные байты при чтении.
    - /dev/urandom (6): специальный файл, который возвращает не криптографически безопасные
    случайные байты при чтении.
```

```txt
8 - proc -  это псевдо-файловая система в Linux, которая предоставляет информацию о процессах, 
            системе и оборудовании, виртуальная файловая система, которая не хранится на диске,
            а вместо этого генерируется ядром Linux в реальном времени.

->  Файлы процесса:
    - /proc/<PID>/cmdline: командная строка процесса
    - /proc/<PID>/environ: переменные окружения процесса
    - /proc/<PID>/fd: файловые дескрипторы процесса
    - /proc/<PID>/maps: информация о памяти процесса
    - /proc/<PID>/mem: информация о памяти процесса
    - /proc/<PID>/status: информация о статусе процесса
    - /proc/<PID>/task: информация о задачах процесса

    - /proc/version: информация о версии ядра
    - /proc/stat: информация о статистике системы
    - /proc/uptime: информация о времени работы системы
    - /proc/loadavg: информация о средней загрузке системы
    - /proc/diskstats: информация о статистике дисков
    - /proc/partitions: информация о разделах дисков
    - /proc/mdstat: информация о RAID-массивах

    - /proc/cpuinfo: информация о процессоре
    - /proc/meminfo: информация о памяти
    - /proc/net/tcp: информация о TCP-соединениях
    - /proc/net/udp: информация о UDP-соединениях
    - /proc/net/raw: информация о RAW-соединениях
    - /proc/net/ip: информация о IP-адресах
    - /proc/net/route: информация о маршрутах
    - /proc/net/dev: информация о сетевых устройствах
    - /proc/net/nf_nat: информация о NAT-таблице
    - /proc/net/nf_queue: информация о очереди пакетов
```

```txt
9 - inode

->  Это структура данных в файловой системе Unix, которая содержит метаданные о файле или 
    каталоге. Inode представляет собой запись в таблице inode, которая хранится на диске и
    содержит информацию о файле или каталоге, такую как:
    - идентификатор inode (i-node number)
    - тип файла (например, обычный файл, каталог, символическая ссылка)
    - права доступа (владелец, группа, права чтения, записи и выполнения)
    - время создания, последнего доступа и последней модификации файла
    - размер файла
    - количество жёстких ссылок на файл
    - указатели на блоки данных файла на диске

    Когда вы создаёте файл или каталог, операционная система создаёт новый inode и присваивает
    ему уникальный идентификатор. Inode содержит информацию о файле, но не содержит сами данные
    файла. Данные файла хранятся в отдельных блоках на диске, а inode содержит указатели на эти
    блоки.

    - ограничение на количество inode, зависит от размера таблицы inode, которая хранится на 
    диске, когда все inode используются, файловая система не может создать новые файлы или
    каталоги, даже если на диске ещё есть свободное место

    df -i
    Файловая система - Inodes - IUsed - IFree -  IUse% - Mounted on
    - Удалить ненужные файлы и каталоги
    - Переместить файлы на другую файловую систему
    - Увеличить размер таблицы inode
    tune2fs -O resize_inode <устройство>
    - Переключиться на файловую систему с динамическим размером inode: Некоторые файловые
    системы, такие как XFS и Btrfs, имеют динамический размер inode, что означает, что они
    могут автоматически увеличивать или уменьшать количество inode в зависимости от потребностей
    - Использовать команду fsck: Если вы обнаружили, что файловая система имеет повреждённую
    таблицу inode, вы можете использовать команду fsck для восстановления файловой системы и
    освобождения inode.
    fsck -f <устройство

    ext4|XFS|Btrfs|F2FS|NTFS|HFS|FAT
```

```txt
10 - alinks

->  Жёсткие ссылки -  это специальный тип ссылки на файл, который позволяет нескольким именам
                      файла ссылаться на один и тот же файл на диске.
    Оба имени файла (оригинальное и новое) имеют одинаковый inode (индексный узел), что
    означает, что они оба указывают на один и тот же файл на диске
    - Они не занимают дополнительное место на диске, поскольку они не создают новый файл,
    а только новое имя файла
    - Они не могут ссылаться на файлы на других файловых система
    - Они не могут ссылаться на директории
    - Они не могут быть удалены, пока существует хотя бы одна ссылка на файл
```

```txt
11 - Какие есть состояния у процессов в Linux?

->  В Linux процессы могут находиться в нескольких состояниях, которые определяют
    их текущий статус и поведение. Вот основные состояния процессов в Linux:

    - R (Running): Процесс находится в состоянии выполнения
    и использует процессор.
    - S (Sleeping): Процесс находится в состоянии сна и ожидает завершения операции
    ввода/вывода или сигнала.
    - D (Disk Sleep): Процесс находится в состоянии сна и ожидает завершения
    операции ввода/вывода с диска.
    - T (Stopped): Процесс находится в состоянии остановки и не выполняется.
    - Z (Zombie): Процесс находится в состоянии зомби и завершен, но его родительский
    процесс еще не получил сигнал о завершении.
    --> сообщить родительскому процессу:
      * Перезапуск родительского процесса: Когда родительский процесс перезапускается, init 
      (процесс с PID 1) становится новым родителем для зомби-процессов и автоматически очищает их.
      * Отправка сигнала SIGCHLD родительскому процессу:  Можно попытаться «разбудить»
      родительский процесс и заставить его вызвать wait(), отправив ему сигнал SIGCHLD. 
      Это можно сделать с помощью команды kill -s SIGCHLD <PID родительского процесса>.
      * Уничтожение родительского процесса:  Если родительский процесс не отвечает на SIGCHLD и
      его нельзя перезапустить, единственный способ избавиться от зомби — уничтожить
      родительский процесс.  Когда родительский процесс завершается, init становится родителем
      зомби-процессов и очищает их.
    - X (Dead): Процесс находится в состоянии мертвого процесса и не может быть восстановлен.
    - P (Paging): Процесс находится в состоянии страницирования и ожидает завершения
    операции страницирования.
    - W (Waiting): Процесс находится в состоянии ожидания и ожидает завершения операции
    ввода/вывода.
    
    
    Например: ps -l Выводит список процессов с их состояниями.
    top Выводит список процессов с их состояниями в режиме реального времени.
```

### <a id="Web">Web</a>

```txt
1 - Методы HTTPS

->  GET, POST, PATCH, DELETE, OPTIONS, PUT, HEAD, PUSH, PRIORITY
    GET -> у него нет тела, передается в адресной строке, кешируется
    POST -> есть тело, отдельный заголовок
```

```txt
2 - Сертификаты

->  Синхронное быстрее, чем асинхронное (в контексте шифрование)
```

```txt
3 - DHCP

->  dynamic host configuration protocol
    Протокол прикладного уровня модели TCP-IP.
    Назначение IP-адреса клиенту, его можно установить вручную, но DHCP автоматически это 
    делает + диагностика подключений и переход из одной подсети в другую

    1 - discovery 
    - init - нет своего ip
    - отправляет broadcast сообщения на все устройства в локальной сети
    - dhcp-server-port-67
    - dhcp-offer-68
    2 - offer
    - dhcp-server предлагает ip из scope (есть ограничения и исключения)
    - dhcp-server - reservation ip - выделяет ip временно (можно назначить навсегда)
    - offer содержит ip из доступной области, предлагает broadcast|unicast сообщение, которое
      идентифицируется по MAC-адресу
    3 - request
    - клиент получает offer, отправляет request на сервер
    - принимает ip и уведомляет об этом 
    - broadcast сообщение == discovery + уникальный ip
    - сервер помечает ip как занятый
    4 - acknowledgement
    - сервер получает от клиента request и сообщает broadcast DHCPACK (владелец и срок)
    - серверы выбирают знакомых клиентов 
```

```txt
4 - ping vs traceroute

->  ping
    1 - ping в терминале Linux, указывая IP-адрес или доменное имя цели
    2 - Linux отправляет запрос в DNS-сервер для разрешения доменного имени в IP-адрес.
        DNS-сервер возвращает IP-адрес цели
    3 - Linux создает пакет ICMP типа Echo Request с вашим IP-адресом в качестве источника и
        IP-адресом цели в качестве назначения
    4 - Linux определяет, как добраться до цели, используя таблицу маршрутизации.
        Если цель находится в той же подсети, что и ваш компьютер, пакет отправляется
        напрямую. Если цель находится в другой подсети, Linux использует default
        gateway (по умолчанию шлюз) для отправки пакета.
    5 - Если цель находится в другой подсети, Linux отправляет пакет ICMP через default
        gateway. Default gateway - это IP-адрес маршрутизатора или шлюза, который соединяет
        вашу подсеть с остальной частью сети или Интернетом
    6 - Default gateway получает пакет ICMP и маршрутизирует его к следующему узлу на пути к
        цели. Этот процесс повторяется, пока пакет не достигнет цели
    7 - Цель получает пакет ICMP и обрабатывает его. Если цель отвечает на эхо-запрос, она
        отправляет пакет ICMP типа Echo Reply обратно к вам
    8 - Пакет ICMP типа "Эхо-ответ" возвращается к вам через тот же путь, которым он 
        был отправлен. Default gateway и другие маршрутизаторы по пути помогают доставить
        пакет обратно к вам
    9 - Linux получает пакет ICMP типа "Эхо-ответ" и выводит результаты команды ping, включая
        время round-trip (RTT) и количество потерянных пакетов

    - icmp пакет к адресу и ожидает ответ
    - достигает - возвращает ответный пакет (информацию о времени передачи и других параметрах)
    - доступность адреса

    traceroute
    - udp пакет к указанному адресу с увеличивающимся TTL (сколько пакет может быть переслан
    маршрутизаторами прежде чем он будет удален)
    - traceroute-пакет - маршрутизатор - TTL уменьшается на 1 - и отправляет пакет дальше, 
      если TTL = 0 маршрутизатор отправляет icmp-пакет time exceeded обратно к отправителю
    - показывает узлы, потому что требует отправлять от маршрутизатора информацию о 
      промежуточных узлах в ICMP-пакетах
    - диагностика сетевых проблем/промежуточные узлы 
```

```txt
5 - Таблица маршрутизации

->  - Маршрутизатор получает пакет - ICMP
    - Маршрутизатор проверяет таблицу маршрутизации
      (есть ли у него запись для адреса 8.8.8.8)
    - Маршрутизатор сравнивает адрес назначения с записями в таблице маршрутизации
      (сравнивает адрес назначения 8.8.8.8 с записями в таблице маршрутизации, в таблице 
      маршрутизации содержится информация о сетях и хостах, которые маршрутизатор знает)
    - Маршрутизатор ищет запись с наибольшим совпадением
      (маршрутизатор ищет запись в таблице маршрутизации, которая большего всего совпадает
      с адресом назначения 8.8.8.8 longest prefix match)
    - Маршрутизатор определяет следующий прыжок (если запись в таблице есть, то
      маршрутизатор определяет следующий hop для пакета, next hop -> адрес следующего 
      маршрутизатора или хоста, который пакет должен посетить на пути к адресу назначения)
    - Маршрутизатор пересылает пакет - на следующий hop, указанный в таблице маршрутизации

    RIP-ASN-OSPF-BGP
```

```txt
6 - Пример таблицы маршрутизации

->  Хранит информацию о том, как пакеты данных должны быть направлены между
    сетями
    route -n/ip route show
    Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
    0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 wlan0
    192.168.1.0     0.0.0.0         255.255.255.0   U     9      0        0 wlan0

    - Destination — это сетевой адрес, к которому пакеты направляются.
    - Gateway — это шлюз, через который пакеты направляются к указанной в Destination сети.
    - Genmask — это маска подсети, которая определяет диапазон адресов, которые относятся к
    данной записи.
    - Flags — это флаги, которые определяют тип записи и поведение маршрутизации. Обычно
    встречаются флаги U (маршрут доступен) и G (шлюз).
    - Metric — это метрика, которая определяет стоимость маршрута. Маршруты с более низкой
    метрикой предпочитаются.
    - Ref — это количество ссылок на этот маршрут.
    - Use — это количество пакетов, которые были отправлены по этому маршруту.
    - Iface — это интерфейс, через который пакеты направляются.

    - Первая запись (0.0.0.0) указывает, что пакеты, направленные в любую сеть (адрес 0.0.0.0 —
    это wildcard, обозначающий любую сеть), должны быть направлены через шлюз 192.168.1.1 на
    интерфейсе wlan0. Это означает, что для доступа в Интернет пакеты будут направляться через
    этот шлюз.
    - Вторая запись (192.168.1.0) указывает, что пакеты, направленные в локальную сеть
    192.168.1.0/24, должны быть направлены напрямую на интерфейсе wlan0, без использования
    шлюза.
```

```txt
7 - Посмотреть открытые порты

->  netstat -tlnp - показывает все открытые TCP-порты, включая номер порта, протокол, адрес и
                    PID процесса, который использует порт
    netstat -ulnp - показывает все открытые UDP-порты

    lsof -i - показывает все открытые интернет-сокеты, включая номер порта и PID процесса, 
              который использует порт
    lsof -i :<номер_порта> - показывает информацию о процессе, который использует указанный порт


    nmap -sT -O localhost - показывает открытые TCP-порты на локальной машине
    nmap -sU -O localhost - показывает открытые UDP-порты на локальной машине

    ss -tlnp - показывает все открытые TCP-порты, включая номер порта, протокол, адрес и PID
               процесса, который использует порт
    ss -ulnp - показывает все открытые UDP-порты

    tcpdump -i any -n -vv -s 0 -c 100 -W 100 - показывает информацию о сетевом трафике, включая
                                               номера портов
    
    ufw status - показывает текущее состояние брандмауэра и открытые порты
    ufw show <номер_порта> - показывает информацию о правиле брандмауэра для указанного порта

    iptables -n -L -v - показывает текущее состояние таблицы правил iptables, включая открытые
                        порты
```

```txt
8 - Балансировка трафика

->  Процесс распределения входящего сетевого трафика между несколькими серверами для увеличения
    пропускной способности, снижения нагрузки и повышения доступности приложений.
    - Используйте балансировщик нагрузки, такой как HAProxy или NGINX.

    1 - Распределение нагрузки по кругу (Round-Robin): Этот метод распределяет входящий трафик
    между серверами в круговом порядке. Каждый новый запрос отправляется на следующий сервер в
    списке.
    - Настройте балансировщик нагрузки для использования метода Round-Robin.
    - Добавьте список серверов, между которыми будет распределяться нагрузка.
    - Настройте параметр "roundrobin" или "rr" в конфигурационном файле балансировщика нагрузки.
      HAProxy:
      frontend http
          bind *:80
          default_backend servers
      backend servers
          mode http
          balance roundrobin
          server server1 192.168.1.1:80 check
          server server2 192.168.1.2:80 check
    
    2 - IP-способность (IP Hash): Этот метод распределяет входящий трафик на основе IP-адреса
    клиента. Каждый клиент всегда направляется на один и тот же сервер.
    - Настройте балансировщик нагрузки для использования метода IP Hash.
    - Добавьте список серверов, между которыми будет распределяться нагрузка.
    - Настройте параметр "iphash" или "ih" в конфигурационном файле балансировщика нагрузки.
    HAProxy:
    frontend http
        bind *:80
        default_backend servers
    backend servers
        mode http
        balance iphash
        server server1 192.168.1.1:80 check
        server server2 192.168.1.2:80 check

    3 - Балансировка на основе содержимого (Content): Этот метод распределяет входящий трафик
    на основе содержимого запроса. Например, запросы на изображения могут направляться на
    сервер, специализирующийся на обработке изображений.
    - Настройте балансировщик нагрузки для использования метода содержимого.
    - Добавьте список серверов, между которыми будет распределяться нагрузка.
    - Настройте параметр "content" или "c" в конфигурационном файле балансировщика нагрузки.
    - Укажите правила для определения содержимого запроса.
    frontend http
        bind *:80
        default_backend servers
    backend servers
        mode http
        balance content
        server server1 192.168.1.1:80 check
        server server2 192.168.1.2:80 check
        content rule1 path_beg /images/
        content rule2 path_beg /videos/

    4 - Динамическая балансировка нагрузки (Dynamic): Этот метод анализирует текущую нагрузку
    на серверах и распределяет входящий трафик на основе доступной мощности.
    - Настройте балансировщик нагрузки для использования метода динамической балансировки.
    - Добавьте список серверов, между которыми будет распределяться нагрузка.
    - Настройте параметр "dynamic" или "d" в конфигурационном файле балансировщика нагрузки.
    - Укажите алгоритм динамической балансировки (например, leastconn).
    HAProxy: 
    frontend http
        bind *:80
        default_backend servers
    backend servers
        mode http
        balance dynamic
        server server1 192.168.1.1:80 check
        server server2 192.168.1.2:80 check
        server server3 192.168.1.3:80 check
        dynamic leastconn

    5- Балансировка на основе скорости ответа (Response Time): Этот метод распределяет входящий
    трафик на основе скорости ответа серверов. Серверы с более быстрой скоростью ответа
    получают больше трафика.
    - Настройте балансировщик нагрузки для использования метода скорости ответа.
    - Добавьте список серверов, между которыми будет распределяться нагрузка.
    - Настройте параметр "response-time" или "rt" в конфигурационном файле балансировщика нагрузки.
    - Укажите время ожидания ответа для каждого сервера.
    frontend http
        bind *:80
        default_backend servers
    backend servers
        mode http
        balance response-time
        server server1 192.168.1.1:80 check rt 100ms
        server server2 192.168.1.2:80 check rt 200ms
        server server3 192.168.1.3:80 check rt 300ms

    6 - Балансировка на основе количества соединений (Least Connection): Этот метод
    распределяет входящий трафик на основе количества активных соединений на серверах.
    Серверы с меньшим количеством соединений получают больше трафика.
    - Настройте балансировщик нагрузки для использования метода количества соединений.
    - Добавьте список серверов, между которыми будет распределяться нагрузка.
    - Настройте параметр "least-conn" или "lc" в конфигурационном файле балансировщика нагрузки.
    frontend http
        bind *:80
        default_backend servers
    backend servers
        mode http
        balance least-conn
        server server1 192.168.1.1:80 check
        server server2 192.168.1.2:80 check
        server server3 192.168.1.3:80 check

    7 - Балансировка на основе весов (Weighted Load Balancing) - это метод балансировки
    нагрузки, при котором каждый сервер имеет свой вес, который определяет долю нагрузки,
    которую он может обрабатывать.
    Принцип работы
    При балансировке на основе весов каждый сервер имеет свой вес, который представляет собой
    коэффициент, определяющий долю нагрузки, которую он может обрабатывать. Вес сервера может
    быть задан в процентах или в абсолютных значениях. Когда клиент отправляет запрос на сервер,
    балансировщик нагрузки определяет, какой сервер должен обработать запрос, на основе весов
    серверов. Сервер с более высоким весом имеет более высокие шансы получить запрос.
    frontend http
        bind *:80
        default_backend servers

    backend servers
        mode http
        server serverA 192.168.1.1:80 weight 30
        server serverB 192.168.1.2:80 weight 40
        server serverC 192.168.1.3:80 weight 30
```

### <a id="PostgreSQL">PostgreSQL</a>

```txt
1 - Какие есть и где конфиги postgres?

->  1 - postgresql.conf -> psql -c "SHOW config_file;"
      - соединение 
      - безопасность
      - кеширование/буферизация
      - журналирование
    2 - pg_hba.conf -> psql -c "SHOW hba_file;"
      - доступа к базе данных (например, разрешение доступа к определенным базам данных,
        пользователям или группам)
      - аутентификация (например, пароли, SSL)
      - авторизация (например, права доступа к таблицам, представлениям)

    Могут быть etc/postgres/config
    Либо внутри postgres как кластерное решение
```

```txt
2 - Сетевой доступ к базе данных?

->  telnet, netcat, curl, busybox
```

```txt
3 - Пользователи

->  Юзер-группа -> устарели 
    login with -> user
    login without -> группа

    Роль = пользователь -> роль можно передавать другим пользователям

    Права - (изменение, удаление)-(схем, таблиц)
    Роль RO + пользователи -> db права -> GRANT ALL DEFAULT ON VIEWS TO testrole;
    template-0 | template-1

```

```txt
4 - Нет места на диске

->  Сборщик мусора -> 
    1 -> отмечает старые данные -> их можно перезаписывать -> DB не уменьшается
    2 -> отключает всех ->  DB уменьшается

    pg_archivecleanup -> это утилита, которая удаляет ненужные архивные файлы WAL из каталога 
                        архивов -d -n -v

    Write-Ahead Logging - это механизм, который используется в DB.
    - WAL - это журнал, который записывает все изменения, которые происходят в базе данных.
    - WAL записывает изменения перед тем, как они будут применены к базе данных.
    - WAL позволяет восстановить базу данных в случае сбоя или ошибки.
    - WAL обеспечивает целостность и надежность данных в базе данных.
    Пример:
    - Когда вы выполняете команду INSERT, UPDATE или DELETE в базе данных, WAL записывает
    изменения в журнал.
    - Если база данных выходит из строя или происходит ошибка, WAL позволяет восстановить базу
    данных до последнего известного состояния.

    Преимущества WAL:
    - Обеспечивает целостность и надежность данных в базе данных.
    - Позволяет восстановить базу данных в случае сбоя или ошибки.
    - Увеличивает производительность базы данных, поскольку изменения записываются в журнал
    перед тем, как они будут применены к базе данных.
```

### <a id="k8s">k8s</a>

```txt
1 - Обновить ядро linux на нодах кластера?

->  - sudo apt update | sudo apt upgrade | reboot
    - kubectl drain/uncordon <node-name>
```

```txt
2 - Пропинговать 2 пода 

->  svc -> clusterIP -> name.svc.namespace.cluster.local
```

```txt
3 - limits/requests

->  requests -> 
    - минимальное количество ресурсов, которые контейнер или под требует для работы
    - определяют количество ресурсов, которые будут выделены контейнеру или поду при его
      запуске

    limits -> 
    - это максимальное количество ресурсов, которые контейнер или под может использовать
    - определяют верхний предел ресурсов, которые контейнер или под может использовать
    - могут быть превышены, если контейнер или под требует больше ресурсов, чем указано в
      requests

    reboot -> DRAM
    throttling -> CPU 
```

```txt
4 - Метрики в кластере

->  kube-state-metrics
```

### <a id="Ansible">Ansible</a>

```txt
1 - Handlers

->  - Handler (обработчик) в Ansible - это специальный тип задачи, который выполняется только
    в том случае, если была изменена какая-либо переменная или ресурс.
    - Handler нужен для того, чтобы выполнять определенные действия после того, как были изменены
    какие-либо ресурсы или переменные. Например, если вы обновили конфигурацию веб-сервера,
    handler может перезапустить сервис, чтобы изменения вступили в силу.
    - Handler используется для выполнения действий, которые необходимо выполнить после изменения
    ресурсов или переменных. Это может быть перезапуск сервиса, reload конфигурации, отправка
    уведомления и т.д.
```

### <a id="Bash">Bash</a>

```txt
1 - Debug 

->  set -x -> позволит вам видеть команды, которые выполняются в скрипте, и их результаты
    set -e -> для остановки скрипта при возникновении ошибки
    set -u -> для вывода ошибки при использовании неопределенной переменной
    bash -v script.sh вывода команд, которые выполняются в скрипте
    bash -x script.sh для запуска скрипта в режиме отладки
```

### <a id="OBS">OBS</a>

```txt
1 - Логирование 

->  Настройка fluetbit  -> DS
    "autodiscovery"
    - docker - log-driver
    - k8s - var/log/containerd/pods
          - var/lib
```

```txt
2 - Различие

->  Logstash -> преобразователь логов (.json)
    Metrics -> prometheus -> 14days (TSDB)
```
